#+TITLE: Test Case Generation Using Fuzzing In C++
#+OPTIONS: num:nil toc:nil
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \lstset{language=c++,keywordstyle=\color{violet},basicstyle=\ttfamily}
* Inbox :noslides:
** efop logo / elte logo
** content
*** reduce introduction
*** shorter demo for cefp
** code
*** output sanitizercoverage flags
*** fix output colors
* How do we verify software?
** Unit Testing
**** Advantages
1. Essential for writing quality software
2. Most straightforward to reason about compared to other methods
3. Faster to implement and run
**** Disadvantages
1. Not trivial to choose meaningful combinations
2. Hard to determine edge cases
3. Relies too much on the developer

\note{Let's illustrate this problem by the simplest example. And I will use this class later to show how the program works}
** Example
\lstinputlisting[language=C++,firstline=3]{test/integrationTestClass.h}
\note{This class has few primitive members, and already requires /TODO/As a result, other means have been developed}
** Example
\lstinputlisting[language=C++,firstline=12,lastline=22]{test/integrationTestClass.cc}
** Static & Dynamic Analysis
- Used for finding vulnerabilities
- Concentrates on edge cases, not on general logic of the application
- As opposed to unit testing, it is *independent* from the developer \note{so it's
  general, foolproof}
# *** TODO can be seen as edge cases
\note{Most relevant for this project was}
* Fuzzing
** About
*** Exposes Interface vulnerabilities
- Ones that are hard to detect manually
- Achieves results in very short time
*** In order to produce input, it uses
- Generational and mutation-based methods
- Coverage-guided engine
** LibFuzzer
- Library in clang
- Coverage guided, evolutionary fuzzing engine by LLVM
- /TODO/ heartbleed bug
** How LibFuzzer Works
User simply has to implement a function that
- accepts an array of bytes
- (possibly) manipulates these bytes and passes it to API

API is usually expected to
- Have single endpoint that consumes any kind of data \note{because otherwise there will be too many complexities and variabilities}
- No exceptions, aborts, exits, crashes, timeouts
- Very first instance of any of it will cause termination
\note{and the user will recieve info on which input caused the crash and where}
\note{I decided to see the internals and how it works. use the same library but instead of ... measure ....}
* Coverage based fuzzing for generating test cases

\note{As I mentioned, traditionally fuzzing hasn't been used for this purpose before since it makes some different assumptions about its target. These are}
** Motivation
- Unit tests verify that *functions* have behave as expected for a particular
  *internal state*
- Ideally, internal state is the result of other function calls
- Therefore, we could treat a single test case as a sequence of function calls
** What is different from fuzzing
Instead of using *sequence of bytes* as input, we will generate *sequence of member function calls*
** What is different from fuzzing :cefp:
\note{just short remark}
*** Some changes
- User will need to pass more information to the program, compared to
  \note{so it's a little bit more verbose}
- Expect control flow disruptions and save which ones caused it
** Overall description of the solved problems
We need something that will
\note{independent functionalities}

1. Store pointers to member functions
   \note{we will need different type signatures, managing arguments, etc}
2. Generate sequences of calls
   \note{this is a fuzz related problem.}
3. Observe coverage resulting from these calls
   \note{introduce SanitizerCoverage library here}
4. Compare the results and determine most efficient

* Demo
** Summary
This program could enable developers to
- automatically generate *minimal* test cases with *high coverage* for their
  libraries
  \note{and therefore,}
- have a *generic* helper for testing the *logic* of the application, just like
  static&dynamic analysis for vulnerabilities
* Thank you for attention
* Demo :noslides:
** Installation
only build and test
mention unit tests
** Set up the main file
\note{metnion that users are developers and editing is expected}
** Run and discuss results
** Show memory errors
