#+TODO: TODO UPNEXT DOING REVIEW | DONE CANCELLED
#+OPTIONS: \n:t H:5 toc:nil title:nil 
#+LATEX_CLASS: book 

:PROPERTIES:
:EXPORT_TITLE: Test Case Generation Based On Fuzzing For C++
:END:

#+LATEX_HEADER: \date{2019}

#+LATEX_HEADER: \degree{Computer Science BSc}

#+LATEX_HEADER: \supervisor{Zoltan Porkolab}
#+LATEX_HEADER: \affiliation{Associate Professor, PhD}


#+LATEX_HEADER: \university{Eötvös Loránd University}
#+LATEX_HEADER: \faculty{Faculty of Informatics}
#+LATEX_HEADER: \department{Department of Programming Languages}
#+LATEX_HEADER: \departmentSecondLine{ And Compilers } 
#+LATEX_HEADER: \city{Budapest}
#+LATEX_HEADER: \logo{elte_cimer_szines}
#+LATEX_HEADER: \documentlang{english}

\setcounter{page}{1}
#+TOC: headlines 0

* Inbox                                                            :noexport:
** DONE thesis declaration
CLOSED: [2019-01-28 Mon 21:11]
added on [2018-12-26 Wed 13:42]
** CANCELLED https://mcss.mosra.cz/doxygen/
CLOSED: [2019-05-08 sze 13:13]
** tasks
** Code tasks 
*** DONE components
CLOSED: [2019-05-08 sze 14:11]
**** CANCELLED generate reports
CLOSED: [2019-05-08 sze 13:13]
**** CANCELLED use a separate class in the extern functions
CLOSED: [2019-05-08 sze 13:13]
*** TODO move the sanitizercoverage flag to coveragereported
don't forget to update docs
*** DONE add an integration test
CLOSED: [2019-05-08 sze 13:14]
*** results
**** CANCELLED have the set of covered pc blocks and check when it reaches max, halt
CLOSED: [2019-05-08 sze 13:14]
***** maybe when the block doesn't have any new covered pc, apply some different rules
**** CANCELLED have some messages for the user
CLOSED: [2019-05-08 sze 13:14]
# :)
*** TODO change colors for the printresults output (main and integration test)
 added on [2019-05-08 sze 01:15]
*** TODO in functionPointerMap talk about all the cool features I'm using
 added on [2019-04-13 szo 13:23]
*** TODO try out testing an hpp file
 added on [2019-05-08 sze 08:43]
** Thesis tasks
*** figs
! Don't forget to have captions and refer to them from the text
**** code snippets
**** TODO binary tree for permutationGenerator
*** other notes
**** you should aim for the shorter combination length
**** determining when to insert a sequence that is a union of two sets is not trivial
*** technical - writing
**** TODO fix section-subsection etc
 added on [2019-05-08 sze 09:12]
**** TODO go through listings and number them
 added on [2019-05-08 sze 08:59]
**** TODO references chapter
*** technical 
**** TODO fix page for refman
 added on [2019-05-08 sze 08:36]
**** TODO listings inlcude line numberings
 added on [2019-05-08 sze 09:04]
**** TODO myrefman compile error for doxygen package
 added on [2019-05-08 sze 08:35]
**** TODO thesis margins check
*** TODO add a separate section for tests and describe test scenarios. 
** TODO add filenames to listing captions
 added on [2019-05-09 cs 13:25]
* Introduction
Most software heavily relies on unit tests as its primary source for logic and _fault tolerance_ verification. This approach has been largely considered as essential, but it has some inherent difficulties associated with it. Although testing single member functions independently is more often than not trivial, most of the time the user will call various combinations of them. It is impossible to write unit tests with all possible function call sequences since such space is effectively infinite. Therefore, the need arises for the developer to personally determine which function call sequences are most meaningful. 

Other than that, a lot of times the behavior of the function will depend on internal state of the instance, which is in itself reached after certain function calls.
** Background
*** Fuzzing
Dynamic analysis, or fuzzing, is a popular and effective method of finding vulnerabilities in software. Fuzz testing reaches impressive results in exposing interface vulnerabilities in very short amount of time. 

Fuzzing heavily relies on the concept of Fuzz target - a function that accepts an array of bytes and then uses it in user defined way against the API under test. This API usually has a single endpoint that consumes any kind data. Anything that causes an exception, abort, exit, crash, assert failure, timeout is considered a bug[1]. That means, discovery of the first instance of any one of them will cause the libfuzzer to halt and inform us about the input that caused the bug, along with some other information. 

There are a number of tools available for fuzzing, including AFL and Radamsa. One of the most notable implementations is Libfuzzer, LLVM's tool for coverage guided, evolutionary fuzzing engine[2]. The code coverage information for libFuzzer is provided by LLVM’s SanitizerCoverage instrumentation, and I will discuss it in the next subsection.
*** SanitizerCoverage library
LLVM has an interface for its built-in code coverage instrumentation[3]. The user is able to gather information about the covereged regions of the program during runtime. There are severeal different levels of depth for coverage, and the library also offers rich ways to trace the data flow. This tool was crucial for the development of my program and in the developer's manual, I discuss the library in more detail.

** _using fuzz testing for .._
Although fuzz testing has been mostly defined to be for exploiting the vulnerabilities of the program, _we decided_ to apply its coverage based philosophy to explore the possible member function call sequences and pinpoint ones which might be most interesting for the developer.
This also required to change the overall approach with which fuzzing is used. 

In [[Fuzzing]] Background on Fuzzing, I talked about the classical assumptions about the fuzz target. In our scenario, we have different expectations - since we are testing an entire unit and not a single API endpoint, some kind of control flow disruptions might be expected. For example, assertions are common in member functions. Therefore, the previous approach of exiting on first such failure should be modified to allow the program to gather information about all possible combinations that result in things like exceptions, so the user will be informed about them and decide what constitues the normal behavior of their library and what is outside of specifications.

** Program description
To acheive the intended results, I created a program that uses LLVM's _sanitizer coverage_ library and generation based fuzzing. The test case needs almost minimal setup which consists of the user specifying all the member functions it wants to use in testing, and passing a single function pointer for constructing an instance of the class. Modern c++ tools have aided greatly with this by giving the ability to store pointers to functions with different type signatures. There are still difficulties with regards to determining and passing the function arguments, which is in scope of a larger _research / project_. In order for this issue to not interfere with the initial program implementation, I allow users to additionally pass pointers to the functions that will in turn call the specific member function with desired arguments.

The _sanitizer coverage_ library is able to communicate its results using a single global object. _(more about this)_ 
** Results
Although the original intention was to discover new test cases, there were some surprising outcomes that could not have been anticipated. For example, the program is very good in minimizing the total number of test cases. For the sample stack class, it discovered that in . This outcome would be crucial for reducing the size of test suites, which leads to reduced runtime and maintenance cost
* User Documentation
This chapter provides full information for users of the program. I am using a simple stack implementation as an example. 

** intended audience
this software is intended for c++ developers who would like to increase 
Therefore, at least basic knowledge of c++ is assumed, and the user will need to implement and pass pointers for several functions.
*** Requirements
_(....)_ and test target class should satisfy following:
**** The program is intended to test a single unit
Current version can not analyze any of the dependencies of the class in some cases. Although the feature might be able to work with multiple classes and different member functions, only single one is supported at this stage.
**** You need to be able to be compiled separately
In order to analyze , the object file of the test target needs to be compiled with special flags separately from the rest of the project. This means the implementation of the class can not be spread in multiple files, and those files should not contain anything else
** dependencies
** installation instructions
run these commands from the directory where you want to install the project
#+ATTR_LATEX: :float nil
#+BEGIN_listing
# download the contents from the provided disk  
cd <dir> # where dir is the path of the folder

make test-main
# this command runs unit tests on classes 

make test # to make sure that everything works
#+END_listing
After tests pass successfully, you can move on to next step and set up the  
** Instructions using an example
After installation, and successful tests _(TODO)_
*** Sample stack  class
[[Listing _TODO_]] shows the definition for the class that the project tests by default. Full implementation can be found in corresponding \lstinline{.cpp} file of the same directory. I will go through the example and explain how it can be adjusted for any other class.
#+CAPTION: definition for the stack class in examples/stack.h
#+BEGIN_listing
\inputminted[firstline=6,lastline=24]{c++}{examples/stack.h}
#+END_listing
*** Structure of the main file
The user is adviced to only change the contents of \lstinline{main} function, and replace the \lstinline{#include} directive. More details about how these classes work and way they are engineered can be found in the [[Developer Documentation]] Developer Documentation _(TODO)_

**** Global objects
# #+ATTR_LaTeX: :float t :placement [H]
#+CAPTION: example file
#+BEGIN_listing
\inputminted[firstline=10,lastline=15]{c++}{src/main.cc}
#+END_listing
# src c++ also works
# \inputminted{excluded}{"~/.emacs" :lines "5-10"   Include lines 5 to 10,}
# \inputminted{excluded}{"~/.emacs" :lines "-10"    Include lines 1 to 10,}
# \inputminted{EOF}{"~/.emacs" :lines "10-"    Include lines from 10}
# **** _maybe_ using the script

**** Getting the output
After finishing, you can ask the coverageReporter to show results by simply printing it or writing to a file
_(functions here)_
*** Compile and run
using commands
#+BEGIN_SRC bash
make run-guards
#+END_SRC
This command will _(....relevant section from the makefile)_
|
|
*** output
_(TODO)_
**** results
|
|
|
**** memory leaks
After it's finished running
#+BEGIN_EXAMPLE
==32362==ERROR: LeakSanitizer: detected memory leaks
#+END_EXAMPLE
Since the program will be compiled using the `-fsanitize=address` compiler flag, any existing memory leaks will be discovered. 
_(example with a stack class but missing constructor)_
For more info about interpreting and fixing these messages visit AddressSanitizer.
** troubleshooting
There are few mistakes 
*** installation
the tests are designed so that all of the underlying infrastructure will be checked. If you start having any problems:
**** test if clang build works correctly
There might be problems with the addressSanitizer. To see if the program can run independently, use the make command, which will compile and run all the source files without the flag. The program will still work and call functions, but the coverage will not be reported. If this step is successful _describe how_ then please _check your compiler_
*** running
|
_(TODO reproduce)_
|
**** Out of Memory error for AddressSanitizer
This happens because _..._. Please refer to the requirements section. This error could be fixed by tweaking the AdressSanitizer, but as for now is not supported in the project. 
* Developer Documentation
This chapter discusses the structure and contents of the source directory, essential concepts for development and reasoning behind some of the architecture decisions. It also provides overview of the tools necessary for development, along with their usage.
** Information about the project
Before going in-depth about the details of software, I would like to elaborate more on some commands that were dicusses in the User Manual.
*** Makefile and project layout
As mentioned before, the project is compiled using GNU make, since it was more straightforward to express the different compilation commands and necessary flags for Sanitizer library. Each recipe is self documenting by using @echo to display its purpose when invoked. Since this is the most crucial information, it is highlighted in shell output. After that the compile command is displayed in less bright color, so the user and developer are not distracted.

Here is a brief overview of the source directory. Each of the subdirectories is displayed alongside corresponding variable in the Makefile.

**** include - $(INC)
Header files. Definitions for all classes of the project. It also contains definition of the template classes along with ther implementation. The \lstinline{lib} subdirectory holds the header file of the testing framework.
**** src - $(SRCDIR)
Implementations of non-template classes from \lstinline{include} directory and a sample for the main file, which should be replaced by user for its own test target unit.
**** bin and build - $(BUILDDIR)
Output for binary and object files
**** test
Test directory. Tests are discussed in detail in [[Testing strategy]] Testing strategy.
*** code conventions
Code is formatted according to LLVM coding standard[fn:1]. Clang-format is used and can be added to commit hook, or alternatively use clang-format plugin for IDE of your choice. 
** Dependencies and internal architecture
*** Sanitizer Coverage library
The program relies primarily on LLVM's built in coverage instrumentation to measure coverage of different function cal sequences. Basic understanding of how these functions work is necessary for development.

_(paragraph about guards,)_


Let me illustrate this using an example. First let us introduce a simple class on [[Listing 3]]. Most functions have descriptive names and their implementation does exactly that, so I will explain only what link [[f2() ]]does, and also note that f4() returns a simple integer value without any calculations. 
#+CAPTION: Definition of the class used in integration tests
#+BEGIN_listing c++
\inputminted[firstline=3,lastline=16]{c++}{test/integrationTestClass.h}
#+END_listing

As you will observe on [[Listing 3]], there are 3 different scenarios for link [[f2()]], and Sanitizer Coverage will insert guards on entry point of each of them. The rest of the functions will simply have guards inserted in the beginning.

#+CAPTION: Implementation of [[IntegrationTestClass::f2()]], with inserted guards highlighted _(TODO)_
#+BEGIN_listing c++
\inputminted[firstline=12,lastline=22]{c++}{test/integrationTestClass.cc}
#+END_listing

Sanitizer Coverage library offers numerous ways to observe the control flow of the program, three default ones being _(.... edge, block, explain differences)_. It also includes _(... for switches and )_. These could aid in refining the program for more complex applications but will not be covered here since only edge case is used currently.
# documentation
*** Example

You will observe that tweaking the number of maximum sequence length will increase the number of covered blocks per unit test (and have larger sequences of function calls) while significantly decreasing the total number of unit tests, until it collapses to very few, maybe even one. It is not reasonable to test the entire logic in a single test, and also not clear _(when to stop growing)_, and it might also vary from the complexity of the unit. However, it will never replace _..._, as observed when tweaking the number from 6 to 7 for IntegrationTestClass.
Right now, it is recommended to start with smaller number of function calls. It is hard to determine the threshold after which having a larger coverage per unit test stops being important. If we restrict the program to only save the function call sequence if it covers a new block, the number of unit tests will _(TODO? I think this is actually a reasonable approach, and should be the default and I could say that other alternatives could be found, at the same time, I don't think I have time to implement, test and document even such a small feature, since I did added other ones recently)._ 
Choosing the right combination of number of function calls with regards to number of covered blocks is for another project. 

This was a higher-level overview of the core concepts used for the program. The rest of the documentation is provided in the following section. 
*** documentation
All classes are thoroughly documented in header files, and some more detailed explanation and reasoning is sometimes provided in implementation files. For documentation generation, Doxygen library is used with javadoc style. 

Run link [[doxygen Doxyfile]] to generate documentation in html and latex source. Latex source needs additional compiling which can be done by running the command \lstinline{make} in the link [[latex/]] directory. If you would like to change doxygen settings, you can copy the Doxyfile and run doxygen link [[my-Doxyfile]].

_(TODO the blank rest of the page here to bind second pdf)_
** Testing strategy
The project is thoroughly tested using the catch2 framework. Tests are represented with Behavior-driven Given-When-Then style, and described scenarios carefully follow documentation. This library was chosen for its minimalistic setup and ability to describe the test cases with full sentences. 

*** Catch2 library
Catch is a multi-paradigm test framework for C++, distributed as a single header file. Though that does not mean that it needs to be compiled into every translation unit.  Since it needs to be defined just once and used for any test case, it is possible and more efficient to compile it to an object file which is later included in tests, as displayed on [[listing _(TODO and other)]]. In the Makefile, value of \lstinline{TESTDIR} is test.

#+CAPTION: contents of test/catch2-main.cpp
#+BEGIN_listing
\inputminted{c++}{test/catch2-main.cpp}
#+END_listing

#+CAPTION: compilation recipe for catch2-main.cpp
#+BEGIN_listing
\inputminted[firstline=67,lastline=72]{bash}{Makefile}
#+END_listing

Unit tests follow the convention by having the corresponding class name followed by "-test" suffix, and their compilation recipe is shown in [[listing _(TODO)_]]. The exception to this is the integration test, which will be discussed in the section _(TODO [Example])_. It serves as a good demonstration for showing how the library works, before going into the details about each unit. First, I will give a brief overview to the Sanitizer Coverage library and introduce the test class which will illustrate core concepts of both the library and my program.

#+CAPTION: including compiled catch2-main.cpp in tests
#+BEGIN_listing
\inputminted[firstline=74,lastline=90]{bash}{Makefile}
#+END_listing

_(TODO reference)_

*** Example 
The library was created mostly by test driven development. Before listing all of the test cases, I will walk through one example in more detail. Unit with most scenarios was \lstinline{CoverageReporter}, since it needs to decide when the new coverage was meaningful/worth storing.

*** List of test case scenarios 


* references                                                       :noexport:
[1] https://github.com/CppCon/CppCon2017/blob/master/Demos/Fuzz%20Or%20Lose/Fuzz%20Or%20Lose%20-%20Kostya%20Serebryany%20-%20CppCon%202017.pdf
[2] https://llvm.org/docs/LibFuzzer.html
[3] https://clang.llvm.org/docs/SanitizerCoverage.html



_(TODO? are the references ok like that?)_

** TODO move stuff from Footnotes
* Footnotes                                                        :noexport:

[fn:1] https://llvm.org/docs/CodingStandards.html
https://clang.llvm.org/docs/ClangFormatStyleOptions.html
https://github.com/catchorg/Catch2/blob/master/docs/slow-compiles.md#top
